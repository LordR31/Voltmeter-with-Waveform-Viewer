{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Voltmeter &amp; Waveform Viewer Documentation Page","text":"<p>This page is dedicated to the Voltmeter &amp; Waveform Viewer Project developed as a final project my EmSys Course.</p>"},{"location":"#block-diagram","title":"Block Diagram","text":""},{"location":"#electrical-diagram","title":"Electrical Diagram","text":""},{"location":"adc/","title":"ADC","text":"<p>The Analog Digital Converter (ADC) used by the Jade M1 Board is a 10bit ADC. The ADC was used to develop the Voltmeter side of the project.</p> <p>The ADC was configured as follows:</p> <ul> <li>using channel 0</li> <li>using AVCC as refference</li> <li>prescalar was set to 128</li> <li>used with the polling method, not with interrupts.</li> </ul> <p></p>"},{"location":"avrdude/","title":"Setting up AVRDUDE","text":"<p>This project was developed using Windows 11. As such, AVRDUDE was downloaded and set up for that OS.</p> <p>Access the Release tab of the official GitHub Repo and download the latest version of AVRDUDE, for Windows. Unpack the files on the C drive, or any equivalent drive, but in an easy to access folder.</p> <p>Now we need to add the tool to path. Pressing the Windows key and searchinig for \"edit environment variables\" should bring up the menu to add the tool to path. Click on Path, then Edit. Click New, to create a new entry, then Browse and select the folder where you extracted the downloaded files from the release tab. Click OK to exit and open a terminal, to test if the set up was successful</p> <p>Simply typing \"avrdude\" and hitting enter should return this:</p> <p></p>"},{"location":"board/","title":"Development Platform","text":"<p>The development platform used for this project is a GroundStudio Jade M1 Board, featuring an ATMega 2560. The Board runs at a frequency of 16MHz, but this is enough for this project.</p> <p>It offers generous resources for a embedded applications and for this project we made use of the ADC, SPI controller and many GPIO pins for buttons and display control.</p> Pin Function Description PD0 Cursor Left Moves the cursor to the previous recorded point PD1 Cursor Right Moves the cursor to the next recorded point PD2 Touch IRQ Pin used for Touchscreen ISR PD3 Voltage Toggle Toggles between High Voltage and Low Voltage PE3 Start Button Enables the ADC and starts the system PB4 Display DC Data/Control Pin for the display PB5 Display Reset Pin used for Display Reset PB6 Display CS Display Chip Select Pin used to signal SPI communication to the display PB7 Touchscreen CS Touchscreen Chip Select Pin used to signal SPI communication with the XPT2046 PF0 ADC Input Channel 0 for the board's ADC used as Voltmeter Input PB1 SPI SCK Clock Pin for SPI communication PB2 SPI MOSI MOSI Pin for SPI communication PB3 Touchscreen MISO MISO Pin used by XPT2046 <p></p>"},{"location":"board/#perf-board","title":"Perf Board","text":"<p>For the hardware part, it is recomended to solder the components to a Perf Board. This is a schematic to use for placing the components.</p> <p></p>"},{"location":"buttons/","title":"Buttons","text":"<p>There are 4 physical buttons and 4 touchscreen buttons. In this section we are only talking about the physical buttons. The other 4 buttons will be discussed inside the Touchscreen section section of the Display documentation.</p> <p>All physical buttons are configured to work with interrupts in falling edge mode. As such, they are all connected to a GPIO pin and to the board's GND.</p> <p>The 4 physical buttons are:</p> <ul> <li>System Start</li> <li>Voltage Mode Toggle</li> <li>Cursor Left</li> <li>Cursor Right</li> </ul>"},{"location":"buttons/#system-start","title":"System Start","text":"<p>Connection: PE4 (Pin 2)</p> <p>This button is used to start and stop the ADC.</p>"},{"location":"buttons/#voltage-mode-toggle","title":"Voltage Mode Toggle","text":"<p>Connection: PD3 (Pin 18)</p> <p>As explained in the previous section, this button toggles the Voltmeter mode from High Voltage to Low Voltage and vice-versa</p>"},{"location":"buttons/#cursor-left","title":"Cursor Left","text":"<p>Connection: PD0 (Pin 21)</p> <p>When the Waveform Viewer is active and the cursor is turned on, this button moves the cursor to the previous recorded point.</p>"},{"location":"buttons/#cursor-left_1","title":"Cursor Left","text":"<p>Connection: PD1 (Pin 20)</p> <p>When the Waveform Viewer is active and the cursor is turned on, this button moves the cursor to the next recorded point. </p>"},{"location":"demo/","title":"DEMO","text":"<p>This is a short demo for the project. In this demo we can see the Voltmeter working, storing min and max in the last 25 measurements. We can see the Waveform Viewer in both digital and analogue mode, as well as the Hold function. Lastly, the cursor is also showcased.</p>"},{"location":"display/","title":"Display","text":"<p>The display used in this project uses an ILI9341 controller and an XPT2046 for resistive touchscreen. It communicates with the board over SPI and it has a resolution of 340x240.</p>"},{"location":"display/#the-defined-ui","title":"The defined UI","text":"<p>When you first power on the board, you are greeted with this screen</p> <p></p> <p>After pressing the start button, we enter the Voltmeter mode, where we can measure signal and up to 25 values are recorded. The UI looks like in the following image.</p> <p></p> <p>On the top, left side of the UI is the Voltmeter area. When the cursor is turned on, the voltmeter measurement gets pushed slightly upward to make space for the cursor measurement. On the right side, also on top, we can have the area which specifies the Voltage Type (H or L) and the indicator \"LEDs\" which tell, in a visual manner, the amount of voltage measured. One LED turns on every 2.4V. The last LED is red, to signal maximum voltage, while the previous 3 LEDs are orange, to signal we are close to the maximum voltage.</p> <p>On the right side we have the touch buttons, while in the middle, we have the Waveform Viewer area. When the Waveform Viewer is turned off, most of the space is taken by the measurements for the maximum and minimum value for the recorded points.</p> <p>When the Waveform Viewer is turned on, two horizontal lines appear on the screen to mark the limits of the Waveform Viewer, on top and bottom. The measurements for the minimum and maximum value get moved to their respective line and the text gets scaled down. They are now used as the upper and lower range for the Waveform Viewer, which has auto-scaling.</p> <p></p> <p>The Waveform Viewer has two modes, a simple mode, where the points are plotted and just connected with dots, and a digital mode, where the samples are also drawn (vertical lines to the points)</p> <p></p>"},{"location":"display/#touchscreen-buttons","title":"Touchscreen Buttons","text":"<p>The button menu on the right side contains the following buttons:</p> <ul> <li>Cursor</li> <li>Hold</li> <li>Wave</li> <li>Toggle</li> </ul>"},{"location":"display/#cursor","title":"Cursor","text":"<p>The cursor button enables and disables the cursor. The cursor is a vertical line which can be moved to the left or to the right of the screen using the designated physical buttons, always ending up on a recorded point. It is used to see the voltage of the selected point inside the voltmeter area.</p> <p></p> <p>When pressed while the Waveform Viewer is turned off, a warning message appears, informing the user that the cursor cannot be used without that feature.</p> <p></p>"},{"location":"display/#hold","title":"Hold","text":"<p>The hold button halts voltage recording, making the Waveform Viewer keep the current form. This feature is useful when paired with the cursor, to check up on signal variations.</p>"},{"location":"display/#wave","title":"Wave","text":"<p>The wave button enables or disables the Waveform Viewer. The Waveform Viewer enables the user to see the form of the signal, up to 25 previous points. This feature is useful for detecting changes in signal strenght and, as stated before, it works best when paired with the cursor and the hold feature.</p>"},{"location":"display/#toggle","title":"Toggle","text":"<p>The toggle button is used to toggle between the two modes for the Waveform Viewer. Similar to the cursor button, when pressed while the Waveform Viewer is turned off, a warning message appears, informing the user that the toggle button cannot be used without that feature.</p> <p></p>"},{"location":"howto/","title":"How to flash the board","text":"<p>To flash the Jade M1 board you need to use an AVR programmer. As such, we will use AVRDUDE to flash out binaries onto the board.</p>"},{"location":"howto/#getting-the-binaries","title":"Getting the binaries","text":"<p>To get the compiled binaries, go to the Release tab on the Github Repository and download the .hex file.</p>"},{"location":"howto/#using-avrdude","title":"Using AVRDUDE","text":"<p>To falsh the binaries onto the board we will use AVRDUDE, in Windows Terminal. AVRDUDE needs to be set up before usage. The set up process can be seen here. After setting up, we will use the following command:</p> <p><code>avrdude -C \"C:\\avrdude\\avrdude.conf\" -c wiring -p atmega2560 -P COM4 -b 115200 -D -U flash:w:\"firmware.hex\":i</code></p> <p>The COM port needs to be changed to match the actual COM Port used by the board. For ease of usage, this command can be stores inside a bat file, as such:</p> <p><code>@echo off  avrdude -C \"C:\\avrdude\\avrdude.conf\" -c wiring -p atmega2560 -P COM4 -b 115200 -D -U flash:w:\"firmware.hex\":i</code></p> <p>If the hex file name is changed, or AVRDUDE will be used with a different binary, firmware.hex can be replaces with %1.hex. This will allow the user to call the .bat file with the binary name, so that you do not have to write and change the command every flash.</p> <p>After saving the .bat file, it can be simply called from terminal with</p> <p>.\\flash.bat or, if using the \"%1.hex\" syntax, .\\flash.bat name.hex.</p>"},{"location":"howto/#avrdude-flags-explained","title":"AVRDUDE Flags Explained","text":"Flag Meaning -C: Specifies the path to the configuration file (avrdude.conf). -c Defines the programmer type. wiring is used for boards like Arduino Mega. Jade M1 uses ATMega2560 -p Specifies the target microcontroller. In this case, it's the ATmega2560. -P Sets the communication port. COM4 is the serial port connected to the board. This needs to be changed based on actual port used. -b Sets the baud rate for communication. 115200 is typical for Arduino Mega uploads. -D Disables auto erase before writing flash. Useful for preserving EEPROM or speeding up uploads. -U flash:w:\"firmware.hex\":i Uploads (w) the file firmware.hex to the flash memory. The :i indicates Intel Hex format."},{"location":"software/","title":"Program Logic","text":"<p>The program logic can be divided into 3 parts, starting from the high level software to the low level hardware. </p>"},{"location":"software/#block-diagram","title":"Block Diagram","text":"<p>The first and upper layer is the Application Layer. This is the high level software that was developed for the program to be able to run and it includes all the functions and libraries / modules developed.</p> <p>The next layer is the Service Layer, which refers to the ISR functions used by the system for the hardware and software buttons, as well as the Timer1 delay functions.</p> <p>Lastly, at the lowest level, there is the Hardware Layer, which is represented by the hardware components and peripherals used in this project. It includes the SPI and ADC peripherals, as well as the hardware buttons used for various system functions.</p> <p></p>"},{"location":"software/#program-work-flow","title":"Program Work Flow","text":"<p>The program logic is best understood when paired with a flow chart, such as the one below.</p> <p>After the system is powered-on, we wait for the user to press the Start Button. When that happens, we turn on the ADC and clear the screen. We check to see if we keep the voltage type as is or toggle it, then we check if we need to process any touchscreen command. We measure the voltage using the ADC, we store the points and get the minimum and maximum values among the last 25 measurements.</p> <p>We check to see if the Waveform Viewer is turned on and if it is set to display in digital or analogue mode. If the Waveform Viewer is on, we check if the cursor is on and if any of the cursor buttons were pressed, then we get cursor voltage.</p> <p>Finally, we draw the indicator LEDs and the loop can begin again.</p> <p></p>"},{"location":"spi/","title":"SPI","text":"<p>The Spi peripheral was used to communicate with ILI9341 display controller and XPT2046 touchscreen controller. It was configured to run using:</p> <ul> <li>CPOL</li> <li>CPHA</li> <li>Double speed (SPI2X, 8MHz)</li> <li>Pull-up disabled for MOSI</li> </ul>"},{"location":"spi/#display-initialization-sequence","title":"Display Initialization Sequence","text":"<p>Using a logic analizer we can see the waveform for the SPI communication during display initialization:</p> <p></p> <p>Because the initialization sequence is quite long, a zoomed version, like the one below, is much more useful. Here we can see the bytes being sent and we can compare with the actual initialization code.</p> <p>.</p> <p>Since we are using an Adafruit display, the init sequence uses the same Adafruit initialization matrix. This is a crop of that sequence, to compare against the waveform viewed with the logic analizer.</p> <p></p> <p>We can see the the zoomed in sequence captured with the logic analizer matches the first line of the initiazliation command.</p>"},{"location":"spi/#spi-transfer","title":"Spi Transfer","text":"<p>To further analize how the SPI transfer works, we can zoom in on one of the bytes:</p> <p></p> <p>Here we can see each bit being sent over SPI: <code>0xEF = 1110_1111</code></p>"},{"location":"spi/#set-display-rotation","title":"Set Display Rotation","text":"<p>The logic analizer was also used to show the SPI transfer for setting the display rotation.</p> <p></p> <p>We can compare this against the actual code:</p> <p></p> <p>The system uses Inverted Landscape view. As such, we need to see the values of <code>ILI9341_MADCTL</code>, which is the reg that handles display rotation and the result of <code>MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR</code>.</p> <p></p> <p>The result of that operation is: <code>0x80 | 0x40 | 0x20 | 0x08 = 0xE8</code></p>"},{"location":"voltmeter/","title":"Voltmeter","text":"<p>The voltmeter part of the project, as stated in the previous section, was developed using the board's 10bit ADC. It has two operation modes which can be toggled using one of the buttons:</p> <ul> <li>High Voltage (0 - 24V Range)</li> <li>Low Voltage (0 - 5V Range)</li> </ul> <p>Since the board's ADC can only safely accept signal up to 5V, a voltage divider was used, to bring the 24V from the 24V power supply down to the safe range. As such, measurements in High Voltage mode are not as accurate as the ones in Low Voltage mode.</p> <p>In the electrical diagram found on the home page we can see the circuit used for the Voltmeter measurement. A voltage divider using a 4.8k resistors and a B1K potentiometer were used to scale down the 24V down to the safe 5V range and to allow for different voltage values. Two 1N5817 diodes were used to protect the board on the 5V and GND terminals. To further simulate different voltage levels, the ADC Input also goes through a B1K potentimeter.</p> <p>As stated, the toggle between High Voltage and Low Voltage is done by using the voltage button, but the change is just a software one. Because we need to scale down the voltage before feeding it to the ADC's input, we can choose to use it as is, in the 0-5V range, which gives us the low voltage mode, or scale it back up after measurements, to get the \"actual\" voltage. This voltage can be turned up or down artifically through the usage of the B1K potentiometer.</p>"}]}